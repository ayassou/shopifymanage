from flask_sqlalchemy import SQLAlchemy
from flask_login import UserMixin
from datetime import datetime
from sqlalchemy import Float, Text, JSON

# Initialize SQLAlchemy
db = SQLAlchemy()

class ShopifySettings(db.Model):
    """Model for Shopify API settings"""
    id = db.Column(db.Integer, primary_key=True)
    api_key = db.Column(db.String(255), nullable=False)
    password = db.Column(db.String(255), nullable=False)
    store_url = db.Column(db.String(255), nullable=False)
    api_version = db.Column(db.String(50), nullable=False, default='2023-07')
    is_active = db.Column(db.Boolean, default=True)
    is_valid = db.Column(db.Boolean, default=False)  # Whether API credentials are valid
    shop_name = db.Column(db.String(255), nullable=True)  # Store name from Shopify API
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    last_used_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self):
        return f'<ShopifySettings {self.store_url}>'

class AISettings(db.Model):
    """Model for AI API settings"""
    id = db.Column(db.Integer, primary_key=True)
    api_provider = db.Column(db.String(50), nullable=False, default='openai')
    api_key = db.Column(db.String(255), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    last_used_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self):
        return f'<AISettings {self.api_provider}>'

class UploadHistory(db.Model):
    """Model for tracking product upload history"""
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(255), nullable=False)
    file_type = db.Column(db.String(50), nullable=False)  # CSV, XLSX, etc.
    record_count = db.Column(db.Integer, default=0)
    success_count = db.Column(db.Integer, default=0)
    error_count = db.Column(db.Integer, default=0)
    upload_date = db.Column(db.DateTime, default=datetime.utcnow)
    settings_id = db.Column(db.Integer, db.ForeignKey('shopify_settings.id'), nullable=True)
    
    # Relationship with ShopifySettings
    settings = db.relationship('ShopifySettings', backref=db.backref('uploads', lazy=True))
    
    def __repr__(self):
        return f'<UploadHistory {self.filename} - {self.upload_date}>'

class ProductUploadResult(db.Model):
    """Model for storing individual product upload results"""
    id = db.Column(db.Integer, primary_key=True)
    upload_id = db.Column(db.Integer, db.ForeignKey('upload_history.id'), nullable=False)
    shopify_product_id = db.Column(db.String(255), nullable=True)
    product_title = db.Column(db.String(255), nullable=False)
    status = db.Column(db.String(50), nullable=False)  # success, error
    message = db.Column(db.Text, nullable=True)
    row_number = db.Column(db.Integer, nullable=True)
    
    # SEO fields
    meta_title = db.Column(db.String(255), nullable=True)
    meta_description = db.Column(db.Text, nullable=True)
    meta_keywords = db.Column(db.Text, nullable=True)
    url_handle = db.Column(db.String(255), nullable=True)
    category_hierarchy = db.Column(db.Text, nullable=True)
    
    # Relationship with UploadHistory
    upload = db.relationship('UploadHistory', backref=db.backref('results', lazy=True))
    
    def __repr__(self):
        return f'<ProductUploadResult {self.product_title} - {self.status}>'
        
        
class BlogPost(db.Model):
    """Model for storing blog posts generated by AI"""
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False)
    content = db.Column(db.Text, nullable=False)
    summary = db.Column(db.Text, nullable=True)
    featured_image_url = db.Column(db.String(1024), nullable=True)
    
    # Blog post metadata
    author = db.Column(db.String(100), nullable=True)
    publish_date = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    status = db.Column(db.String(50), default='draft')  # draft, published, scheduled
    
    # SEO and categorization
    meta_title = db.Column(db.String(255), nullable=True)
    meta_description = db.Column(db.Text, nullable=True)
    meta_keywords = db.Column(db.Text, nullable=True)
    url_handle = db.Column(db.String(255), nullable=True)
    tags = db.Column(db.Text, nullable=True)  # Comma-separated tags
    category = db.Column(db.String(100), nullable=True)
    
    # Generation parameters (to facilitate regeneration)
    topic = db.Column(db.String(255), nullable=True)
    keywords = db.Column(db.Text, nullable=True)
    tone = db.Column(db.String(50), nullable=True)  # informative, casual, professional, etc.
    target_audience = db.Column(db.String(100), nullable=True)
    word_count = db.Column(db.Integer, nullable=True)
    
    # Shopify integration
    shopify_blog_id = db.Column(db.String(255), nullable=True)
    shopify_post_id = db.Column(db.String(255), nullable=True)
    settings_id = db.Column(db.Integer, db.ForeignKey('shopify_settings.id'), nullable=True)
    
    # Relationship with ShopifySettings
    settings = db.relationship('ShopifySettings', backref=db.backref('blog_posts', lazy=True))
    
    def __repr__(self):
        return f'<BlogPost {self.title} - {self.status}>'


class PageContent(db.Model):
    """Model for storing static page content generated by AI"""
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False)
    content = db.Column(db.Text, nullable=False)
    page_type = db.Column(db.String(50), nullable=False)  # about, faq, contact, terms, privacy, etc.
    summary = db.Column(db.Text, nullable=True)
    image_url = db.Column(db.String(1024), nullable=True)
    
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    published = db.Column(db.Boolean, default=False)
    publish_date = db.Column(db.DateTime, nullable=True)
    
    # SEO fields
    meta_title = db.Column(db.String(255), nullable=True)
    meta_description = db.Column(db.Text, nullable=True)
    meta_keywords = db.Column(db.Text, nullable=True)
    url_handle = db.Column(db.String(255), nullable=True)
    
    # Generation parameters
    company_name = db.Column(db.String(255), nullable=True)
    company_description = db.Column(db.Text, nullable=True)
    industry = db.Column(db.String(100), nullable=True)
    founding_year = db.Column(db.Integer, nullable=True)
    location = db.Column(db.String(255), nullable=True)
    values = db.Column(db.Text, nullable=True)  # Comma-separated values
    tone = db.Column(db.String(50), nullable=True)  # professional, friendly, casual, etc.
    target_audience = db.Column(db.String(100), nullable=True)
    
    # For FAQ pages
    faq_items = db.Column(db.Text, nullable=True)  # JSON string of Q&A pairs
    faq_topics = db.Column(db.Text, nullable=True)  # Topics used to generate FAQs
    
    # For contact pages
    contact_email = db.Column(db.String(255), nullable=True)
    contact_phone = db.Column(db.String(50), nullable=True)
    contact_address = db.Column(db.Text, nullable=True)
    social_media = db.Column(db.Text, nullable=True)  # JSON string of social media links
    
    # Performance metrics
    generation_time = db.Column(db.Float, nullable=True)  # Time taken to generate content in seconds
    
    # Original generation parameters (for regeneration)
    parameters = db.Column(db.Text, nullable=True)  # JSON string of all parameters used
    
    # Shopify page information
    shopify_page_id = db.Column(db.String(255), nullable=True)
    settings_id = db.Column(db.Integer, db.ForeignKey('shopify_settings.id'), nullable=True)
    
    settings = db.relationship('ShopifySettings', backref=db.backref('pages', lazy=True))
    
    def __repr__(self):
        return f'<PageContent {self.title} - {self.page_type}>'


class ImageBatch(db.Model):
    """Model for storing image batch information for caption generation"""
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(255), nullable=False)  # User-defined batch name
    source_type = db.Column(db.String(50), nullable=False)  # url, upload, shopify, search
    source_detail = db.Column(db.Text, nullable=True)  # URL, search terms, or other source info
    
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Batch status tracking
    status = db.Column(db.String(50), default='pending')  # pending, processing, completed, failed
    processed_count = db.Column(db.Integer, default=0)
    total_count = db.Column(db.Integer, default=0)
    
    # Export information
    export_format = db.Column(db.String(50), nullable=True)  # csv, shopify_update, json
    export_path = db.Column(db.String(1024), nullable=True)  # File path for exported data
    
    # Shopify integration
    settings_id = db.Column(db.Integer, db.ForeignKey('shopify_settings.id'), nullable=True)
    settings = db.relationship('ShopifySettings', backref=db.backref('image_batches', lazy=True))
    
    def __repr__(self):
        return f'<ImageBatch {self.name} - {self.source_type}>'


class ImageItem(db.Model):
    """Model for storing individual image information and generated captions"""
    id = db.Column(db.Integer, primary_key=True)
    batch_id = db.Column(db.Integer, db.ForeignKey('image_batch.id'), nullable=False)
    
    # Image information
    filename = db.Column(db.String(255), nullable=True)
    url = db.Column(db.String(1024), nullable=True)
    file_path = db.Column(db.String(1024), nullable=True)  # Local path for uploaded images
    mimetype = db.Column(db.String(100), nullable=True)
    filesize = db.Column(db.Integer, nullable=True)  # in bytes
    
    # Generated data
    alt_text = db.Column(db.String(255), nullable=True)
    caption = db.Column(db.Text, nullable=True)
    tags = db.Column(db.Text, nullable=True)  # Comma-separated tags
    detailed_description = db.Column(db.Text, nullable=True)  # Longer, more detailed description
    
    # SEO data
    seo_keywords = db.Column(db.Text, nullable=True)
    seo_title = db.Column(db.String(255), nullable=True)
    
    # Product association
    product_suggested_name = db.Column(db.String(255), nullable=True)
    product_category = db.Column(db.String(100), nullable=True)
    
    # Processing status
    status = db.Column(db.String(50), default='pending')  # pending, processing, completed, failed
    error_message = db.Column(db.Text, nullable=True)
    
    # Shopify specific information
    shopify_product_id = db.Column(db.String(255), nullable=True)
    shopify_image_id = db.Column(db.String(255), nullable=True)
    shopify_updated = db.Column(db.Boolean, default=False)
    
    # Timestamps
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    processed_at = db.Column(db.DateTime, nullable=True)
    
    # Relationship with ImageBatch
    batch = db.relationship('ImageBatch', backref=db.backref('images', lazy=True))
    
    def __repr__(self):
        return f'<ImageItem {self.filename or self.url[:30]}>'

class User(UserMixin, db.Model):
    """Model for user authentication"""
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(256))
    
    def __repr__(self):
        return f'<User {self.username}>'

# Dropshipping Agent Models
class TrendAnalysis(db.Model):
    """Model for storing trend analysis data"""
    id = db.Column(db.Integer, primary_key=True)
    source = db.Column(db.String(100), nullable=False)  # 'aliexpress', 'amazon', 'tiktok', etc.
    keyword = db.Column(db.String(200), nullable=False)
    search_volume = db.Column(db.Integer, nullable=True)
    growth_rate = db.Column(db.Float, nullable=True)  # percentage growth
    competition_level = db.Column(db.Float, nullable=True)  # 0-1 scale
    seasonality = db.Column(db.String(100), nullable=True)  # 'all-year', 'summer', 'winter', etc.
    data_json = db.Column(JSON, nullable=True)  # Additional data in JSON format
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    products = db.relationship('ProductSource', backref='trend', lazy=True)
    
    def __repr__(self):
        return f'<TrendAnalysis {self.keyword} - {self.source}>'

class ProductSource(db.Model):
    """Model for storing sourced product information"""
    id = db.Column(db.Integer, primary_key=True)
    trend_id = db.Column(db.Integer, db.ForeignKey('trend_analysis.id'), nullable=True)
    name = db.Column(db.String(255), nullable=False)
    description = db.Column(Text, nullable=True)
    source_url = db.Column(db.String(512), nullable=True)
    source_platform = db.Column(db.String(100), nullable=True)  # 'aliexpress', 'alibaba', etc.
    price = db.Column(db.Float, nullable=True)
    shipping_cost = db.Column(db.Float, nullable=True)
    shipping_time = db.Column(db.Integer, nullable=True)  # in days
    profit_margin = db.Column(db.Float, nullable=True)
    moq = db.Column(db.Integer, nullable=True)  # Minimum Order Quantity
    rating = db.Column(db.Float, nullable=True)  # Supplier rating
    weight = db.Column(db.Float, nullable=True)  # in kg
    dimensions = db.Column(db.String(100), nullable=True)  # format: "LxWxH" in cm
    image_urls = db.Column(JSON, nullable=True)  # Array of image URLs as JSON
    is_trending = db.Column(db.Boolean, default=False)
    is_seasonal = db.Column(db.Boolean, default=False)
    data_json = db.Column(JSON, nullable=True)  # Additional data in JSON format
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    evaluations = db.relationship('ProductEvaluation', backref='product_source', lazy=True)
    
    def __repr__(self):
        return f'<ProductSource {self.name} - {self.source_platform}>'
    
class ProductEvaluation(db.Model):
    """Model for evaluating product suitability for dropshipping"""
    id = db.Column(db.Integer, primary_key=True)
    product_id = db.Column(db.Integer, db.ForeignKey('product_source.id'), nullable=False)
    dropshipping_score = db.Column(db.Float, nullable=True)  # 0-100 scale
    market_saturation = db.Column(db.Float, nullable=True)  # 0-1 scale
    shipping_complexity = db.Column(db.Float, nullable=True)  # 0-1 scale
    return_risk = db.Column(db.Float, nullable=True)  # 0-1 scale
    profit_potential = db.Column(db.Float, nullable=True)  # 0-1 scale
    overall_recommendation = db.Column(db.String(50), nullable=True)  # 'highly_recommended', 'recommended', 'neutral', 'not_recommended', 'avoid'
    evaluation_notes = db.Column(Text, nullable=True)
    data_json = db.Column(JSON, nullable=True)  # Additional data in JSON format
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f'<ProductEvaluation {self.product_id} - {self.overall_recommendation}>'

class NicheAnalysis(db.Model):
    """Model for niche market analysis"""
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(200), nullable=False)
    description = db.Column(Text, nullable=True)
    main_keywords = db.Column(JSON, nullable=True)  # Array of keywords as JSON
    search_volume = db.Column(db.Integer, nullable=True)
    competition_level = db.Column(db.Float, nullable=True)  # 0-1 scale
    growth_potential = db.Column(db.Float, nullable=True)  # 0-1 scale
    recommended_products = db.Column(JSON, nullable=True)  # Array of product IDs as JSON
    audience_demographics = db.Column(JSON, nullable=True)  # Demographic data as JSON
    marketing_channels = db.Column(JSON, nullable=True)  # Recommended channels as JSON
    evaluation_notes = db.Column(Text, nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f'<NicheAnalysis {self.name}>'

# Store Agent Models
class StoreSetup(db.Model):
    """Model for store setup and configuration"""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    settings_id = db.Column(db.Integer, db.ForeignKey('shopify_settings.id'), nullable=True)
    store_name = db.Column(db.String(255), nullable=False)
    store_url = db.Column(db.String(512), nullable=False)
    niche = db.Column(db.String(200), nullable=True)
    logo_url = db.Column(db.String(512), nullable=True)
    theme_id = db.Column(db.String(100), nullable=True)
    currency = db.Column(db.String(3), nullable=True)
    status = db.Column(db.String(50), default='pending')  # 'pending', 'in_progress', 'completed', 'failed'
    settings_json = db.Column(JSON, nullable=True)  # Store settings as JSON
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    store_pages = db.relationship('StorePage', backref='store', lazy=True)
    store_products = db.relationship('StoreProduct', backref='store', lazy=True)
    
    # Relationships
    settings = db.relationship('ShopifySettings', backref=db.backref('stores', lazy=True))
    user = db.relationship('User', backref=db.backref('stores', lazy=True))
    
    def __repr__(self):
        return f'<StoreSetup {self.store_name} - {self.status}>'

class StorePage(db.Model):
    """Model for store pages"""
    id = db.Column(db.Integer, primary_key=True)
    store_id = db.Column(db.Integer, db.ForeignKey('store_setup.id'), nullable=False)
    page_type = db.Column(db.String(50), nullable=False)  # 'home', 'about', 'contact', 'policy', 'blog', etc.
    title = db.Column(db.String(255), nullable=False)
    content = db.Column(Text, nullable=True)
    meta_title = db.Column(db.String(255), nullable=True)
    meta_description = db.Column(db.String(512), nullable=True)
    is_published = db.Column(db.Boolean, default=False)
    shopify_page_id = db.Column(db.String(100), nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f'<StorePage {self.title} - {self.page_type}>'

class StoreProduct(db.Model):
    """Model for store products"""
    id = db.Column(db.Integer, primary_key=True)
    store_id = db.Column(db.Integer, db.ForeignKey('store_setup.id'), nullable=False)
    product_source_id = db.Column(db.Integer, db.ForeignKey('product_source.id'), nullable=True)
    title = db.Column(db.String(255), nullable=False)
    description = db.Column(Text, nullable=True)
    price = db.Column(db.Float, nullable=False)
    compare_at_price = db.Column(db.Float, nullable=True)
    sku = db.Column(db.String(100), nullable=True)
    inventory_quantity = db.Column(db.Integer, default=999)
    weight = db.Column(db.Float, nullable=True)
    requires_shipping = db.Column(db.Boolean, default=True)
    images = db.Column(JSON, nullable=True)  # Array of image URLs/data as JSON
    variants = db.Column(JSON, nullable=True)  # Product variants as JSON
    tags = db.Column(JSON, nullable=True)  # Array of tags as JSON
    seo_title = db.Column(db.String(255), nullable=True)
    seo_description = db.Column(db.String(512), nullable=True)
    status = db.Column(db.String(50), default='draft')  # 'draft', 'active', 'archived'
    shopify_product_id = db.Column(db.String(100), nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    product_source = db.relationship('ProductSource', backref=db.backref('store_products', lazy=True))
    
    def __repr__(self):
        return f'<StoreProduct {self.title} - {self.status}>'

class ThemeCustomization(db.Model):
    """Model for theme customization settings"""
    id = db.Column(db.Integer, primary_key=True)
    store_id = db.Column(db.Integer, db.ForeignKey('store_setup.id'), nullable=False)
    theme_id = db.Column(db.String(100), nullable=False)
    primary_color = db.Column(db.String(20), nullable=True)
    secondary_color = db.Column(db.String(20), nullable=True)
    font_heading = db.Column(db.String(100), nullable=True)
    font_body = db.Column(db.String(100), nullable=True)
    logo_position = db.Column(db.String(50), nullable=True)
    hero_layout = db.Column(db.String(50), nullable=True)
    home_page_sections = db.Column(JSON, nullable=True)  # Sections configuration as JSON
    collection_layout = db.Column(db.String(50), nullable=True)
    product_page_layout = db.Column(db.String(50), nullable=True)
    settings_json = db.Column(JSON, nullable=True)  # Additional settings as JSON
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f'<ThemeCustomization {self.store_id} - {self.theme_id}>'

# Agent Process Tracking
class AgentTask(db.Model):
    """Model for tracking agent tasks"""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    task_type = db.Column(db.String(100), nullable=False)  # 'trend_analysis', 'product_sourcing', 'store_setup', etc.
    status = db.Column(db.String(50), default='pending')  # 'pending', 'running', 'completed', 'failed'
    progress = db.Column(db.Integer, default=0)  # 0-100 percent
    result_id = db.Column(db.Integer, nullable=True)  # ID of the result object (depends on task_type)
    result_type = db.Column(db.String(100), nullable=True)  # Model name of the result
    error_message = db.Column(db.Text, nullable=True)
    parameters = db.Column(JSON, nullable=True)  # Task parameters as JSON
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    user = db.relationship('User', backref=db.backref('agent_tasks', lazy=True))
    
    def __repr__(self):
        return f'<AgentTask {self.task_type} - {self.status}>'